#!/usr/bin/env python
"""PySGF solutons to Project Euler Problems 101-150.

http://projecteuler.net/
Solutions presume Python 2.7.

"""

import re
import sys
import time
import urllib
import csv
from contextlib import closing

from data import *
from functions import *

def p101():
    """Project Euler Problem 101 solution.
    
    If we are presented with the first k terms of a sequence it is impossible to say with certainty the value of the next term,
    as there are infinitely many polynomial functions that can model the sequence.

    As an example, let us consider the sequence of cube numbers. This is defined by the generating function,
    u(n) = n^3: 1, 8, 27, 64, 125, 216, ...

    Suppose we were only given the first two terms of this sequence.
    Working on the principle that "simple is best" we should assume a linear relationship and predict the next term to be 15
    (common difference 7). Even if we were presented with the first three terms, by the same principle of simplicity,
    a quadratic relationship should be assumed.

    We shall define OP(k, n) to be the nth term of the optimum polynomial generating function for the first k terms of a sequence.
    It should be clear that OP(k, n) will accurately generate the terms of the sequence for n <= k,
    and potentially the first incorrect term (FIT) will be OP(k, k+1); in which case we shall call it a bad OP (BOP).

    As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; that is, for n >= 2, OP(1, n) = u1.

    Hence we obtain the following OPs for the cubic sequence:
    OP(1, n) = 1 	    1, 1, 1, 1, ...
    OP(2, n) = 7n-6 	    1, 8, 15, ...
    OP(3, n) = 6n^2-11n+6   1, 8, 27, 58, ...
    OP(4, n) = n3 	    1, 8, 27, 64, 125, ...

    Clearly no BOPs exist for k >= 4.
    By considering the sum of FITs generated by the BOPs, we obtain 1 + 15 + 58 = 74.
    Consider the following tenth degree polynomial generating function:
    un = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10
    Find the sum of FITs for the BOPs.
    
    """
    
    def __poly_eval(poly_coefs, xval):
        return sum(coef * xval ** index for (index, coef) in enumerate(poly_coefs))
        
    def __row_reduce(ini_op_vals, ini_sfun_vals, coef_index):
        op_vals = ini_op_vals
        sfun_vals = ini_sfun_vals
        row_index = 0
        for i in xrange(len(op_vals)):
            if i != coef_index:
                row_factor = op_vals[coef_index][coef_index]
                coef_factor = op_vals[i][coef_index]
                op_vals[i] = [x * row_factor - op_vals[coef_index][col_index] * coef_factor  for (col_index, x) in  enumerate(op_vals[i])]
                sfun_vals[i] =  sfun_vals[i] * row_factor - sfun_vals[coef_index] *  coef_factor
                del op_vals[i][coef_index]
                row_index += 1
        del op_vals[coef_index]
        del sfun_vals[coef_index]
        return op_vals, sfun_vals
    
    def _get_coef(op_vals, sfun_vals, coef_num):
        op_vals_red, sfun_vals_red = copy.deepcopy(op_vals), copy.deepcopy(sfun_vals)
        coef_index = coef_num
        while len(op_vals_red) > 1:
            if coef_index != 0:
                coef_to_eliminate = 0
                coef_index -= 1
            else:
                coef_to_eliminate = 1
            op_vals_red, sfun_vals_red = __row_reduce(op_vals_red, sfun_vals_red, coef_to_eliminate)
        coef_val = sfun_vals_red[0] / op_vals_red[0][0]
        return coef_val

    def __get_optimum_polynomial_coefficients(sfun_coefs, nval):
        op_vals = [[x ** n for n in xrange(nval)] for x in xrange(1, nval + 1)]
        sfun_vals = [__poly_eval(sfun_coefs, x) for x in  xrange(1, nval + 1)]
        op_coefs = [_get_coef(op_vals,  sfun_vals, n) for n in xrange(nval)]
        return op_coefs
    
    def __get_fip_value(sfun_coefs, nval):
        op_coefs = __get_optimum_polynomial_coefficients(sfun_coefs, nval)
        fip_val = __poly_eval(op_coefs, len(op_coefs) + 1)
        return fip_val

    sfun_coefs = [(-1) ** n for n in xrange(11)]
    fip_sum = sum(__get_fip_value(sfun_coefs, n) for n in xrange(1, len(sfun_coefs)))
    return fip_sum


def p102():
    """Project Euler Problem 102 solution.
    
    Three distinct points are plotted at random on a Cartesian plane, for which -1000 <= x, y <= 1000, such that a triangle is formed.
    Consider the following two triangles:
    A(-340,495), B(-153,-910), C(835,-947)
    X(-175,41), Y(-421,-714), Z(574,-645)
    It can be verified that triangle ABC contains the origin, whereas triangle XYZ does not.
    Using triangles.txt (right click and 'Save Link/Target As...'), a 27K text file containing the co-ordinates of one thousand "random" triangles,
    find the number of triangles for which the interior contains the origin.
    NOTE: The first two examples in the file represent the triangles in the example given above.
    
    """
    
    def __triangle_area(x1, y1, x2, y2, x3, y3):
        return abs((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3))
    
    def __does_triangle_contain_origin(x1, y1, x2, y2, x3, y3):
        """Triangle contains origin if sum of areas substituting points with origin equals initial triangle area."""
        area_ini = __triangle_area(x1, y1, x2, y2, x3, y3)
        area_total = __triangle_area(x1, y1, x2, y2, 0, 0) + __triangle_area(x1, y1, 0, 0, x3, y3) + __triangle_area(0, 0, x2, y2, x3, y3)
        return area_ini == area_total
    
    originated_triangle_count = 0
    triangle_reader = csv.reader(open('p102_triangles.txt', 'rb'), delimiter = ',', quotechar = '"')
    for coord_list in triangle_reader:
        clist = []
        for coord in coord_list:
            clist.append(int(coord))
        originated_triangle_count += 1 if apply(__does_triangle_contain_origin, clist) else 0
  
    return originated_triangle_count
    
  
  
def p103():
    """Project Euler Problem 103 solution.
       
    Let S(A) represent the sum of elements in set A of size n. We shall call it a special sum set if for any two non-empty disjoint subsets,
    B and C, the following properties are true:
        S(B)  S(C); that is, sums of subsets cannot be equal.
        If B contains more elements than C then S(B) > S(C).
        
        If S(A) is minimised for a given n, we shall call it an optimum special sum set. The first five optimum special sum sets are given below.

        n = 1: {1}
        n = 2: {1, 2}
        n = 3: {2, 3, 4}
        n = 4: {3, 5, 6, 7}
        n = 5: {6, 9, 11, 12, 13}

    It seems that for a given optimum set, A = {a1, a2, ... , an}, the next optimum set is of the form B = {b, a1+b, a2+b, ... ,an+b},
    where b is the "middle" element on the previous row. By applying this "rule" we would expect the optimum set
    for n = 6 to be A = {11, 17, 20, 22, 23, 24}, with S(A) = 117. However, this is not the optimum set,
    as we have merely applied an algorithm to provide a near optimum set. The optimum set for n = 6 is A = {11, 18, 19, 20, 22, 25}, with S(A) = 115
    and corresponding set string: 111819202225.
    Given that A is an optimum special sum set for n = 7, find its set string.
    NOTE: This problem is related to problems 105 and 106.
    
    """
    
    special_sum_set_infos = {}
     
    def get_special_sum_set_infos(nval):
        """Utility function to get the special sum set infos for a given set length. An info is a sum set and its subset sumsize dictionary."""
        
        n_set_infos = special_sum_set_infos[nval] if nval in special_sum_set_infos else []
        return n_set_infos
    
    def set_special_sum_set_info(nval, special_sum_set, subset_sums_set):
        """Utility function to set a special sum set info (i.e. sum set and its subset sumsize dictionary) for a given set length."""
        
        if nval not in special_sum_set_infos:
            special_sum_set_infos[nval] = []
        special_sum_set_infos[nval].append([special_sum_set, subset_sums_set])
        
    def build_new_special_subset_sumsize_dictionary(base_subset_sumssize_dictionary, new_element):
        """Create a new subset sumsize dictionary for set containing base special sum set with new element added."""
        
        if base_subset_sumssize_dictionary:
            if new_element in base_subset_sumssize_dictionary:
                return None
            new_base_subset_sumssize_dictionary = copy.copy(base_subset_sumssize_dictionary)
            new_base_subset_sumssize_dictionary[new_element] = 1
            for sum, num_elements in base_subset_sumssize_dictionary.items():
                if sum + new_element in base_subset_sumssize_dictionary:
                    return None
                new_base_subset_sumssize_dictionary[sum + new_element] = num_elements + 1
                
            # Check if len(B) > len(C) then S(B) > S(C)
            max_elements = 0
            for sum in sorted(new_base_subset_sumssize_dictionary.iterkeys()):
                cur_elements = new_base_subset_sumssize_dictionary[sum]
                if cur_elements < max_elements:
                    return None
                max_elements = cur_elements
            
            return new_base_subset_sumssize_dictionary
        else:
            return {new_element : 1}       
   
    def augment_special_sum_sets(nval, max_element_val):
        """ Update special sum sets according to a new maximum element value."""
        
        if nval > 1:
            n_minus_1_sum_set_infos = get_special_sum_set_infos(nval - 1)
            for base_sum_set_info in n_minus_1_sum_set_infos:
                subset_sumsize_dict = build_new_special_subset_sumsize_dictionary(base_sum_set_info[1], max_element_val)
                if subset_sumsize_dict:
                    set_special_sum_set_info(nval, base_sum_set_info[0].copy().union([max_element_val]), subset_sumsize_dict)
        else:
            set_special_sum_set_info(nval, set([max_element_val]), {max_element_val: 1})
            
    def get_optimum_special_sum_set(nval):
        """ Get the optimum special sum set (i.e. special sum set with lowest sum) for a given number of elements."""
        
        opt_sum_set = None
        sum_val = 0
        for sum_set_info in get_special_sum_set_infos(nval):
            cur_sum = sum(sum_set_info[0])
            if not opt_sum_set:
                opt_sum_set = sum_set_info[0]
                sum_val = cur_sum
            elif cur_sum < sum_val:
                opt_sum_set = sum_set_info[0]
                sum_val = cur_sum
        
        return opt_sum_set
     
    max_element_val = 0
    while True:
        max_element_val += 1
        for x in range(1, 8):
            augment_special_sum_sets(x, max_element_val)
        opt_set = get_optimum_special_sum_set(7)
        if opt_set:
            return ''.join(str(x) for x in sorted(list(opt_set)))

      